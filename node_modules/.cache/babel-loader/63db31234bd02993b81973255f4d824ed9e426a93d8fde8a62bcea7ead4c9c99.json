{"ast":null,"code":"/** @license React v0.11.3\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    /* eslint-disable no-var */\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n\n    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n    var maxSigned31BitInt = 1073741823;\n\n    // Times out immediately\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    // Eventually times out\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000;\n    // Never times out\n    var IDLE_PRIORITY = maxSigned31BitInt;\n\n    // Callbacks are stored as a circular, doubly linked list.\n    var firstCallbackNode = null;\n    var currentDidTimeout = false;\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1;\n\n    // This is set when a callback is being executed, to prevent re-entrancy.\n    var isExecutingCallback = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      }\n      // Schedule the host callback using the earliest expiration in the list.\n      var expirationTime = firstCallbackNode.expirationTime;\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n      _requestHostCallback(flushWork, expirationTime);\n    }\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode;\n\n      // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = firstCallbackNode.next;\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n      flushedNode.next = flushedNode.previous = null;\n\n      // Now it's safe to call the callback.\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n      try {\n        continuationCallback = callback();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      }\n\n      // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n      if (typeof continuationCallback === 'function') {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        };\n\n        // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n            node = node.next;\n          } while (node !== firstCallbackNode);\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n    function flushImmediateWork() {\n      if (\n      // Confirm we've exited the outer most event handler\n      currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n        isExecutingCallback = true;\n        try {\n          do {\n            flushFirstCallback();\n          } while (\n          // Keep flushing until there are no more immediate callbacks\n          firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n        } finally {\n          isExecutingCallback = false;\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n    function flushWork(didTimeout) {\n      isExecutingCallback = true;\n      var previousDidTimeout = currentDidTimeout;\n      currentDidTimeout = didTimeout;\n      try {\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (firstCallbackNode !== null) {\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n              continue;\n            }\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && !shouldYieldToHost());\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n        currentDidTimeout = previousDidTimeout;\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        }\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n      var expirationTime;\n      if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n          case LowPriority:\n            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n            break;\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n      var newNode = {\n        callback: callback,\n        priorityLevel: currentPriorityLevel,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n\n      // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled();\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n        do {\n          if (node.expirationTime > expirationTime) {\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n          node = node.next;\n        } while (node !== firstCallbackNode);\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n      return newNode;\n    }\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      callbackNode.next = callbackNode.previous = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    function unstable_shouldYield() {\n      return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n    }\n\n    // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n    // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n    var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n    var _requestHostCallback;\n    var cancelHostCallback;\n    var shouldYieldToHost;\n    var globalValue = null;\n    if (typeof window !== 'undefined') {\n      globalValue = window;\n    } else if (typeof global !== 'undefined') {\n      globalValue = global;\n    }\n    if (globalValue && globalValue._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var globalImpl = globalValue._schedMock;\n      _requestHostCallback = globalImpl[0];\n      cancelHostCallback = globalImpl[1];\n      shouldYieldToHost = globalImpl[2];\n      exports.unstable_now = globalImpl[3];\n    } else if (\n    // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' ||\n    // Check if MessageChannel is supported, too.\n    typeof MessageChannel !== 'function') {\n      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n      // fallback to a naive implementation.\n      var _callback = null;\n      var _flushCallback = function _flushCallback(didTimeout) {\n        if (_callback !== null) {\n          try {\n            _callback(didTimeout);\n          } finally {\n            _callback = null;\n          }\n        }\n      };\n      _requestHostCallback = function requestHostCallback(cb, ms) {\n        if (_callback !== null) {\n          // Protect against re-entrancy.\n          setTimeout(_requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0, false);\n        }\n      };\n      cancelHostCallback = function cancelHostCallback() {\n        _callback = null;\n      };\n      shouldYieldToHost = function shouldYieldToHost() {\n        return false;\n      };\n    } else {\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n      var scheduledHostCallback = null;\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0;\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      shouldYieldToHost = function shouldYieldToHost() {\n        return frameDeadline <= exports.unstable_now();\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = function (event) {\n        isMessageEventScheduled = false;\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            }\n            // Exit without invoking the callback.\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      };\n      var animationTick = function animationTick(rafTime) {\n        if (scheduledHostCallback !== null) {\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          port.postMessage(undefined);\n        }\n      };\n      _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        timeoutTime = absoluteTimeout;\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          port.postMessage(undefined);\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n      cancelHostCallback = function cancelHostCallback() {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstCallbackNode","currentDidTimeout","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","ensureHostCallbackIsScheduled","expirationTime","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","didTimeout","previousDidTimeout","currentTime","unstable_now","shouldYieldToHost","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","unstable_shouldYield","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","globalValue","window","global","_schedMock","globalImpl","MessageChannel","_callback","_flushCallback","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","event","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","_requestHostCallback","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority"],"sources":["C:/Users/sgaur/Desktop/Frontednd-4/Shopping-Cart/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v0.11.3\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentDidTimeout = false;\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  isExecutingCallback = true;\n  var previousDidTimeout = currentDidTimeout;\n  currentDidTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    currentDidTimeout = previousDidTimeout;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case LowPriority:\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar shouldYieldToHost;\n\nvar globalValue = null;\nif (typeof window !== 'undefined') {\n  globalValue = window;\n} else if (typeof global !== 'undefined') {\n  globalValue = global;\n}\n\nif (globalValue && globalValue._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var globalImpl = globalValue._schedMock;\n  requestHostCallback = globalImpl[0];\n  cancelHostCallback = globalImpl[1];\n  shouldYieldToHost = globalImpl[2];\n  exports.unstable_now = globalImpl[3];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _flushCallback = function (didTimeout) {\n    if (_callback !== null) {\n      try {\n        _callback(didTimeout);\n      } finally {\n        _callback = null;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0, false);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  shouldYieldToHost = function () {\n    return frameDeadline <= exports.unstable_now();\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = function (event) {\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      port.postMessage(undefined);\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      port.postMessage(undefined);\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}